/********************************************************************************************************************************
 *  Author:     	Corey Moura & Xue Hue
 *  Lab:        	3.1  -  "Measuring distance using the proximity sensor"
 *  Date:       	9/4/19
 *  Instructor: 	Dr. Kandalaft
 *
 *  Description:	In this part, you will use the MSP432 in capture mode to determine the length of a pulse generated by a
 *              	proximity sensor included in your kit.  The proximity sensor must be pre-triggered in order to generate a
 *              	pulse so that distance to an object can be determined.Connect your proximity sensor to the MSP432 I/O port
 *              	pins as designed in your pre-lab exercise. BECAREFUL- the proximity sensor must be powered by 5V- so a
 *              	“level shifter” circuit must be used to interface it to the MSP432. Run your program that will output to
 *              	the monitor in 2 second intervals, the distance to the proximity sensor when the object is directly in front
 *              	of the monitor.  Use “printf” to display the value on your CCS window. Repeat your program when an object is
 *              	off axis from the sensor by approximately 20 degrees. Repeat your program one last time when an object is off
 *              	axis from the sensor by approximately -20 degrees.
 *
 *  Notes:      	No Driver Lib, use of custom library
 *
 *
 *******************************************************************************************************************************/
#include <stdint.h>                                 // A set of typedefs that specify exact-width integer types
#include <stdbool.h>                            	// Allow boolean variable to be used
#include <stdio.h>                              	// Standard input output for printf etc.
#include <stdlib.h>                             	// Standard C-programming library
#include <string.h>                             	// Allows the use of strings
#include "msp.h"                                	// Another TI library of some sort
#include <EGR326Lib.h>
#include <math.h>                                	// Another TI library of some sort
 
void inititialize();                            	// Called to initialize all of the MSP features used in the program.
void timerA_Init();                             	// Initializes an instances of timer A
void triggerPulse();                            	// Pulses the output trigger pin for 10uS
void calcDistance();                            	// Calculates the distance to the object using the time interval of captures
 
volatile float numClkCycles = 0;                	// Number of clock cycles in the captured interval
volatile float totalTime = 0;                   	// Total time elapsed in the interval
volatile float distanceInMeters = 0;            	// Distance in meters
volatile float speedOfSound = 340;              	// Speed of sound constant ~340 m/s
volatile float distanceInCm = 0;                	// Converted distance to cm
volatile uint16_t pulseLength = 0;              	// Number of cycles the clock took
 
volatile uint8_t  numCapture = 0;               	// Incremented to track the incoming interrupt values for the CCR reg.
volatile uint16_t captureVal = 0;               	// Assigned the value from the CCR register every interrupt
volatile uint16_t capturedVal_1 = 0;            	// First captured value from the CCR reg is stored here
volatile uint16_t capturedVal_2 = 0;            	// second captured value from the CCR reg is stored here
volatile uint32_t timeout = 0;                  	// Flag set from the syystic interrupt
volatile uint32_t sys_loadVal = 1500000;        	// 1/2Hz = 6600000: Initial value assigned to the systic timer
 
void main(void){
 
	inititialize();
 
	__enable_irq ( );                                       	// enable global interrupts
	NVIC->ISER[0] = 1 << ((TA0_N_IRQn) & 31);               	// Enable interrupt in NVIC vector
 
	while(1){
 
    	if(timeout){
        	timeout = 0;                                    	// Reset the flag
        	triggerPulse();                                 	// Send the trigger pulse
    	}
 
    	if(numCapture == 2){
        	numCapture = 0;                                 	// Reset the counter
        	calcDistance();                                 	// Calculate the distance
        	printf("distanceInCm = %f\n\n", distanceInCm);  	// Print the distance to the console
    	}
 
	}
}
 
/********************************************************************************************************************/
/*  CALCULATING THE DISTANCE:  Calculates the distance from the timer interrupt values.  The number of clock cycles
 *  between reads is calculated into a time value by finding the period of a clock cycle.  The time is multiplied by
 *  the speed of sound and divided by two to compensate for the travel time to and from the object   */
/********************************************************************************************************************/
void calcDistance(){
	numClkCycles = abs(capturedVal_1 - capturedVal_2);     	     // The absolute value of the two captures
	totalTime = 3*pow(10,-7) * numClkCycles;                    	// period of CLK cycle * number of CLK cycles
	distanceInMeters = (speedOfSound * totalTime) / 2;          	// Speed of sound * total time / 2
	distanceInCm = distanceInMeters * 100;                      	// Conversion from m->cm for displaying
}
 
/********************************************************************************************************************/
/*  TIMER A0.2 ISR: This is called whenever the timer object detects an input signal changes.  	*/
/********************************************************************************************************************/
void TA0_N_IRQHandler(void){
	TIMER_A0->CCTL[2] &=~ BIT0;                                 	// Clear the interrupt flag
 
	captureVal = TIMER_A0->CCR[2];                              	// Read the value of the captured TAxR number
 
	numCapture++;                                               	// Track the begining and end of interval
 
	if(numCapture == 1) capturedVal_1 = captureVal;             	// Beginning of interval CCR val is assigned here
	if(numCapture == 2) capturedVal_2 = captureVal;             	// End of interval CCR val is assigned here
}
 
/********************************************************************************************************************/
/*  TRIGGER PULSE: It is required to toggle the trigger pin of the Ultrasonic to initiate a reading   */
/********************************************************************************************************************/
void triggerPulse(){
	P5->OUT  |=  BIT5;                                          	// Toggle bit ON
	_delay_cycles(33);                                          	// Delay set for 10uS as per data sheet of sensor
	P5->OUT  &=~  BIT5;                                     	    // Toggle bit OFF
}
 
 
/********************************************************************************************************************/
/* SYSTICK INTERRUPT HANDLER:  This is called when the systick timer reaches zero from its load value, sets flag  */
/********************************************************************************************************************/
extern void SysTick_Handler(void){
	timeout = 1 ;                                               	// set flag for timeout of SysTick, rest in main
}
 
 
/********************************************************************************************************************/
/* Call out to the functions and initialize the pins and timers used in the program.  */
/********************************************************************************************************************/
void inititialize(){
 
	WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;                 	// stop watchdog timer
 
	timerA_Init();
	Init_SysTick(6600000, 7);                  	                 // Systick initialization
 
	Init_OutputPin(55);                                         	//GPIO ouput pin
	Init_InputPin(25, 1, 0, 0, 0, 0, 0, 0);                     	// Pin2.4, TA, input
 
}
 
/********************************************************************************************************************/
/*  TIMER A INITIALIZATIONS:
 *    	Timer AO.2 used as the input interrupt timer
/********************************************************************************************************************/
void timerA_Init(){
	TIMER_A0->CTL  =  0x0220;           	// SMCLK, interrupts disabled, continuous mode, no divider
	TIMER_A0->CCTL[2] = 0xCD78;         	// Intrpt en, set/rst, capture, sync, CCIxA signal, rising edge
 
}
